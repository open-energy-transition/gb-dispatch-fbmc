# SPDX-FileCopyrightText: gb-open-market-model contributors
#
# SPDX-License-Identifier: MIT

"""
heat demand shape profile generator.

This script generates the heat demand shape for each sector.
"""

import logging
from pathlib import Path

import numpy as np
import pandas as pd
import xarray as xr

from scripts._helpers import configure_logging, set_scenario_config

logger = logging.getLogger(__name__)


def process_demand_timeseries(
    demand_path: str, cop_profile_path: str, heating_mix_path: str, sector: str
) -> pd.DataFrame:
    """
    Generate load profile shape for heat pump demands in each sector

    Args:
        demand_path(str): Filepath to the hourly heat load profiles generated by PyPSA-Eur
        cop_profile_path(str): Filepath to hourly weighted COP profiles generated by PyPSA-Eur
        heating_mix_path(str): Filepath to heating technology mix for each heating sector in FES
        sector(str): Sector considered (residential/services)

    Returns:
        pd.DataFrame : electrified heat demand profile for the sector
    """

    cop_profile = pd.read_csv(cop_profile_path, index_col=["time","name"], parse_dates=["time"])
    heating_mix = pd.read_csv(heating_mix_path, index_col="Technology")

    # Read the heat demand .nc file
    demand = xr.open_dataset(demand_path).to_dataframe().squeeze(axis=1).unstack("node")

    system = ["space", "water"]
    nodes = cop_profile.index.get_level_values("name").unique()
    load_profile = pd.DataFrame(index=demand.index, columns=nodes, data=0)

    for sys in system:
        if sector == "commercial":
            sector_key = "services"
        else:
            sector_key = sector
        demand_sys = demand[f"{sector_key} {sys}"]

        # Compute the electrified heat demand by dividing the heat load by COP
        load = (
            demand_sys.div(cop_profile["ASHP"].unstack("name"))
            * heating_mix.loc["ASHP", sector]
            + demand_sys.div(cop_profile["GSHP"].unstack("name"))
            * heating_mix.loc["GSHP", sector]
            + demand_sys * heating_mix.loc["Electric resistive", sector]
        )

        load.replace([np.inf, -np.inf], 0, inplace=True)

        load_profile += load

    # Normalize the load profile
    load_normalized = load_profile / load_profile.sum()

    return load_normalized


if __name__ == "__main__":
    if "snakemake" not in globals():
        from scripts._helpers import mock_snakemake

        snakemake = mock_snakemake(Path(__file__).stem, year=2022)
    configure_logging(snakemake)
    set_scenario_config(snakemake)

    sectors = ["residential", "commercial"]

    for sector in sectors:
        load_profile = process_demand_timeseries(
            demand_path=snakemake.input.demand,
            cop_profile_path=snakemake.input.cop_profile,
            heating_mix_path=snakemake.input.heating_mix,
            sector=sector,
        )

        # Save the heat demand load profile
        load_profile.to_csv(snakemake.output[f"{sector}_csv_file"])
        logger.info(
            f"{sector} heat demand profile saved to {snakemake.output[f'{sector}_csv_file']}"
        )
